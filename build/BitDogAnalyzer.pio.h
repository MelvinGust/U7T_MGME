// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// sample0 //
// ------- //

#define sample0_wrap_target 0
#define sample0_wrap 0

static const uint16_t sample0_program_instructions[] = {
            //     .wrap_target
    0x4001, //  0: in     pins, 1                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program sample0_program = {
    .instructions = sample0_program_instructions,
    .length = 1,
    .origin = -1,
};

static inline pio_sm_config sample0_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + sample0_wrap_target, offset + sample0_wrap);
    return c;
}
#endif

// ------- //
// sample1 //
// ------- //

#define sample1_wrap_target 0
#define sample1_wrap 0

static const uint16_t sample1_program_instructions[] = {
            //     .wrap_target
    0x4001, //  0: in     pins, 1                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program sample1_program = {
    .instructions = sample1_program_instructions,
    .length = 1,
    .origin = -1,
};

static inline pio_sm_config sample1_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + sample1_wrap_target, offset + sample1_wrap);
    return c;
}
#endif

// ------- //
// sample2 //
// ------- //

#define sample2_wrap_target 0
#define sample2_wrap 0

static const uint16_t sample2_program_instructions[] = {
            //     .wrap_target
    0x4001, //  0: in     pins, 1                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program sample2_program = {
    .instructions = sample2_program_instructions,
    .length = 1,
    .origin = -1,
};

static inline pio_sm_config sample2_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + sample2_wrap_target, offset + sample2_wrap);
    return c;
}
#endif

// ------- //
// sample3 //
// ------- //

#define sample3_wrap_target 0
#define sample3_wrap 0

static const uint16_t sample3_program_instructions[] = {
            //     .wrap_target
    0x4001, //  0: in     pins, 1                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program sample3_program = {
    .instructions = sample3_program_instructions,
    .length = 1,
    .origin = -1,
};

static inline pio_sm_config sample3_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + sample3_wrap_target, offset + sample3_wrap);
    return c;
}

    static inline pio_sm_config sample0_program_init(PIO pio, uint sm, uint offset0, uint in_pin, float div) {
    // Criamos uma estrutura de configuração, apontando à state machine desejada.
    pio_sm_config c = sample0_program_get_default_config(offset0); 
    // Configuramos o pino de entrada para a state machine e depois para o PIO.
    sm_config_set_in_pins(&c, in_pin);
    pio_gpio_init(pio, in_pin);
    // Os dados do pino serão shifted à direita do ISR. Se estava 0b0000, agora seria 0b1000, por 
    // conta de empurrar o 1 da esquerda à direita. O autopush (jogar do ISR para o FIFO) acontece
    // ao preenchermos o ISR com 32 bits.
    sm_config_set_in_shift(&c, true, true, 32);
    // Junto os dois FIFOS para ter um único FIFO grande, o FIFO_RX desta state machine.
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX); 
    // Aplico a configuração na state machine.
    pio_sm_init(pio, sm, offset0, &c);  
    return c;
    }
    static inline pio_sm_config sample1_program_init(PIO pio, uint sm, uint offset1, uint in_pin, float div) {
        pio_sm_config c = sample1_program_get_default_config(offset1); 
        sm_config_set_in_pins(&c, in_pin);
        pio_gpio_init(pio, in_pin);
        sm_config_set_in_shift(&c, true, true, 32);
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX); 
        pio_sm_init(pio, sm, offset1, &c); 
        return c;
    }
    static inline pio_sm_config sample2_program_init(PIO pio, uint sm, uint offset2, uint in_pin, float div) {
        pio_sm_config c = sample1_program_get_default_config(offset2); 
        sm_config_set_in_pins(&c, in_pin);
        pio_gpio_init(pio, in_pin);
        sm_config_set_in_shift(&c, true, true, 32);
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX); 
        pio_sm_init(pio, sm, offset2, &c);  
        return c;
    }
    static inline pio_sm_config sample3_program_init(PIO pio, uint sm, uint offset3, uint in_pin, float div) {
        pio_sm_config c = sample1_program_get_default_config(offset3); 
        sm_config_set_in_pins(&c, in_pin);
        pio_gpio_init(pio, in_pin);
        sm_config_set_in_shift(&c, true, true, 32);
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX); 
        pio_sm_init(pio, sm, offset3, &c); 
        return c; 
    }

#endif

